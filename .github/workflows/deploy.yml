name: Deploy to AWS App Runner

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION:   ap-northeast-1
  ECR_REPO:     tenasia-intelligence-hub   # API/Frontend 공용 (태그로 구분)

jobs:
  # ────────────────────────────────────────────────────
  # Job 1: 테스트
  # ────────────────────────────────────────────────────
  test:
    name: Test
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run tests
        run: python -m pytest test_*.py -v --tb=short
        continue-on-error: true

  # ────────────────────────────────────────────────────
  # Job 2-A: FastAPI 이미지 빌드 & ECR Push
  # ────────────────────────────────────────────────────
  build-api:
    name: Build & Push API
    runs-on: ubuntu-latest
    needs: test

    permissions:
      id-token: write
      contents: read

    outputs:
      image-uri: ${{ steps.push.outputs.image-uri }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push API image
        id: push
        env:
          REGISTRY:  ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build \
            --build-arg BUILD_DATE="$(date -u +'%Y-%m-%dT%H:%M:%SZ')" \
            --build-arg GIT_COMMIT="${{ github.sha }}" \
            -t "$REGISTRY/$ECR_REPO:api-$IMAGE_TAG" \
            -t "$REGISTRY/$ECR_REPO:api-latest" \
            .

          docker push "$REGISTRY/$ECR_REPO:api-$IMAGE_TAG"
          docker push "$REGISTRY/$ECR_REPO:api-latest"

          echo "image-uri=$REGISTRY/$ECR_REPO:api-$IMAGE_TAG" >> "$GITHUB_OUTPUT"

  # ────────────────────────────────────────────────────
  # Job 2-B: Next.js 이미지 빌드 & ECR Push
  #   - NEXT_PUBLIC_API_URL 미설정 → /api 프록시 경유
  #   - FASTAPI_URL 은 deploy-frontend 에서 런타임 주입
  # ────────────────────────────────────────────────────
  build-frontend:
    name: Build & Push Frontend
    runs-on: ubuntu-latest
    needs: test

    permissions:
      id-token: write
      contents: read

    outputs:
      image-uri: ${{ steps.push.outputs.image-uri }}

    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build & Push Frontend image
        id: push
        env:
          REGISTRY:  ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # 기존 ECR 레포(tenasia-intelligence-hub)를 공유, frontend- 태그 접두어로 구분
          docker build \
            -f web-next/Dockerfile \
            --target production \
            -t "$REGISTRY/$ECR_REPO:frontend-$IMAGE_TAG" \
            -t "$REGISTRY/$ECR_REPO:frontend-latest" \
            web-next/

          docker push "$REGISTRY/$ECR_REPO:frontend-$IMAGE_TAG"
          docker push "$REGISTRY/$ECR_REPO:frontend-latest"

          echo "image-uri=$REGISTRY/$ECR_REPO:frontend-$IMAGE_TAG" >> "$GITHUB_OUTPUT"

  # ────────────────────────────────────────────────────
  # Job 3: FastAPI App Runner 배포
  # ────────────────────────────────────────────────────
  deploy-api:
    name: Deploy API
    runs-on: ubuntu-latest
    needs: build-api

    permissions:
      id-token: write
      contents: read

    environment:
      name: production
      url: ${{ steps.url.outputs.value }}

    outputs:
      api-url: ${{ steps.url.outputs.value }}

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy API (start-deployment or recreate if needed)
        id: deploy
        env:
          IMAGE_URI:      ${{ needs.build-api.outputs.image-uri }}
          DATABASE_URL:   ${{ secrets.DATABASE_URL }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        run: |
          set -euo pipefail

          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_ROLE="arn:aws:iam::${ACCOUNT_ID}:role/AppRunnerECRAccessRole"
          SERVICE_NAME="tenasia-intelligence-hub"

          SERVICE_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn | [0]" \
            --output text 2>/dev/null || true)

          if [ -z "$SERVICE_ARN" ] || [ "$SERVICE_ARN" = "None" ]; then
            STATUS="NOT_FOUND"
          else
            STATUS=$(aws apprunner describe-service \
              --service-arn "$SERVICE_ARN" \
              --query 'Service.Status' --output text 2>/dev/null || echo "NOT_FOUND")
          fi
          echo "현재 API 서비스 상태: $STATUS"

          if [ "$STATUS" = "RUNNING" ]; then
            aws apprunner update-service \
              --service-arn "$SERVICE_ARN" \
              --source-configuration "{
                \"ImageRepository\": {
                  \"ImageIdentifier\": \"$IMAGE_URI\",
                  \"ImageConfiguration\": {
                    \"Port\": \"8000\",
                    \"RuntimeEnvironmentVariables\": {
                      \"DATABASE_URL\": \"$DATABASE_URL\",
                      \"GEMINI_API_KEY\": \"$GEMINI_API_KEY\"
                    }
                  },
                  \"ImageRepositoryType\": \"ECR\"
                },
                \"AuthenticationConfiguration\": {\"AccessRoleArn\": \"$ECR_ROLE\"},
                \"AutoDeploymentsEnabled\": false
              }"
            echo "service-arn=$SERVICE_ARN" >> "$GITHUB_OUTPUT"

          else
            echo "서비스 비정상 상태($STATUS) → 삭제 후 재생성"

            if [ "$STATUS" != "NOT_FOUND" ] && [ "$STATUS" != "DELETED" ]; then
              aws apprunner delete-service --service-arn "$SERVICE_ARN" || true
            fi

            echo "서비스 이름 해제 대기 중 (최대 10분)..."
            for i in $(seq 1 30); do
              FOUND=$(aws apprunner list-services \
                --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceName | [0]" \
                --output text 2>/dev/null || echo "")
              echo "  [삭제 대기 $i/30] 잔존: ${FOUND:-없음}"
              if [ -z "$FOUND" ] || [ "$FOUND" = "None" ]; then break; fi
              sleep 20
            done

            jq -n \
              --arg image  "$IMAGE_URI" \
              --arg db     "$DATABASE_URL" \
              --arg gemini "$GEMINI_API_KEY" \
              --arg role   "$ECR_ROLE" \
              '{
                ImageRepository: {
                  ImageIdentifier: $image,
                  ImageConfiguration: {
                    Port: "8000",
                    RuntimeEnvironmentVariables: {
                      DATABASE_URL:   $db,
                      GEMINI_API_KEY: $gemini
                    }
                  },
                  ImageRepositoryType: "ECR"
                },
                AuthenticationConfiguration: {AccessRoleArn: $role},
                AutoDeploymentsEnabled: false
              }' > /tmp/api-config.json

            NEW_ARN=""
            for attempt in 1 2 3; do
              NEW_ARN=$(aws apprunner create-service \
                --service-name "$SERVICE_NAME" \
                --source-configuration file:///tmp/api-config.json \
                --instance-configuration '{"Cpu":"1 vCPU","Memory":"2 GB"}' \
                --health-check-configuration \
                  '{"Protocol":"HTTP","Path":"/health","Interval":10,"Timeout":5,"HealthyThreshold":1,"UnhealthyThreshold":5}' \
                --query 'Service.ServiceArn' --output text 2>&1) && break
              echo "  [생성 시도 $attempt/3] 실패: $NEW_ARN — 30초 후 재시도"
              sleep 30
            done

            if [[ "$NEW_ARN" != arn:* ]]; then
              echo "API 서비스 생성 최종 실패: $NEW_ARN"; exit 1
            fi
            echo "service-arn=$NEW_ARN" >> "$GITHUB_OUTPUT"
          fi

      - name: Wait for API deployment
        run: |
          ARN="${{ steps.deploy.outputs.service-arn }}"
          for i in $(seq 1 30); do
            STATUS=$(aws apprunner describe-service \
              --service-arn "$ARN" --query 'Service.Status' --output text)
            echo "[$i/30] API 상태: $STATUS"
            case "$STATUS" in
              RUNNING)   echo "API 배포 성공!"; exit 0 ;;
              *_FAILED)  echo "API 배포 실패: $STATUS"; exit 1 ;;
            esac
            sleep 30
          done
          echo "타임아웃"; exit 1

      - name: Get API URL
        id: url
        run: |
          ARN="${{ steps.deploy.outputs.service-arn }}"
          URL=$(aws apprunner describe-service \
            --service-arn "$ARN" --query 'Service.ServiceUrl' --output text)
          echo "value=https://$URL" >> "$GITHUB_OUTPUT"
          echo "API URL: https://$URL"

  # ────────────────────────────────────────────────────
  # Job 4: Next.js App Runner 배포
  #   - deploy-api 완료 후 FASTAPI_URL 을 런타임 env 로 주입
  # ────────────────────────────────────────────────────
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [build-frontend, deploy-api]

    permissions:
      id-token: write
      contents: read

    environment:
      name: production-frontend
      url: ${{ steps.url.outputs.value }}

    steps:
      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy Frontend (start-deployment or recreate if needed)
        id: deploy
        env:
          IMAGE_URI:   ${{ needs.build-frontend.outputs.image-uri }}
          FASTAPI_URL: ${{ needs.deploy-api.outputs.api-url }}
        run: |
          set -euo pipefail

          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          ECR_ROLE="arn:aws:iam::${ACCOUNT_ID}:role/AppRunnerECRAccessRole"
          SERVICE_NAME="tenasia-intelligence-hub-frontend"

          SERVICE_ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceArn | [0]" \
            --output text 2>/dev/null || true)

          if [ -z "$SERVICE_ARN" ] || [ "$SERVICE_ARN" = "None" ]; then
            STATUS="NOT_FOUND"
          else
            STATUS=$(aws apprunner describe-service \
              --service-arn "$SERVICE_ARN" \
              --query 'Service.Status' --output text 2>/dev/null || echo "NOT_FOUND")
          fi
          echo "현재 Frontend 서비스 상태: $STATUS"

          if [ "$STATUS" = "RUNNING" ]; then
            aws apprunner update-service \
              --service-arn "$SERVICE_ARN" \
              --source-configuration "{
                \"ImageRepository\": {
                  \"ImageIdentifier\": \"$IMAGE_URI\",
                  \"ImageConfiguration\": {
                    \"Port\": \"3000\",
                    \"RuntimeEnvironmentVariables\": {
                      \"FASTAPI_URL\": \"$FASTAPI_URL\"
                    }
                  },
                  \"ImageRepositoryType\": \"ECR\"
                },
                \"AuthenticationConfiguration\": {\"AccessRoleArn\": \"$ECR_ROLE\"},
                \"AutoDeploymentsEnabled\": false
              }"
            echo "service-arn=$SERVICE_ARN" >> "$GITHUB_OUTPUT"

          else
            echo "서비스 비정상 상태($STATUS) → 삭제 후 재생성"

            if [ "$STATUS" != "NOT_FOUND" ] && [ "$STATUS" != "DELETED" ]; then
              aws apprunner delete-service --service-arn "$SERVICE_ARN" || true
            fi

            echo "서비스 이름 해제 대기 중 (최대 10분)..."
            for i in $(seq 1 30); do
              FOUND=$(aws apprunner list-services \
                --query "ServiceSummaryList[?ServiceName=='${SERVICE_NAME}'].ServiceName | [0]" \
                --output text 2>/dev/null || echo "")
              echo "  [삭제 대기 $i/30] 잔존: ${FOUND:-없음}"
              if [ -z "$FOUND" ] || [ "$FOUND" = "None" ]; then break; fi
              sleep 20
            done

            jq -n \
              --arg image      "$IMAGE_URI" \
              --arg fastapi    "$FASTAPI_URL" \
              --arg role       "$ECR_ROLE" \
              '{
                ImageRepository: {
                  ImageIdentifier: $image,
                  ImageConfiguration: {
                    Port: "3000",
                    RuntimeEnvironmentVariables: {
                      FASTAPI_URL: $fastapi
                    }
                  },
                  ImageRepositoryType: "ECR"
                },
                AuthenticationConfiguration: {AccessRoleArn: $role},
                AutoDeploymentsEnabled: false
              }' > /tmp/frontend-config.json

            NEW_ARN=""
            for attempt in 1 2 3; do
              NEW_ARN=$(aws apprunner create-service \
                --service-name "$SERVICE_NAME" \
                --source-configuration file:///tmp/frontend-config.json \
                --instance-configuration '{"Cpu":"1 vCPU","Memory":"2 GB"}' \
                --health-check-configuration \
                  '{"Protocol":"HTTP","Path":"/healthz","Interval":10,"Timeout":5,"HealthyThreshold":1,"UnhealthyThreshold":5}' \
                --query 'Service.ServiceArn' --output text 2>&1) && break
              echo "  [생성 시도 $attempt/3] 실패: $NEW_ARN — 30초 후 재시도"
              sleep 30
            done

            if [[ "$NEW_ARN" != arn:* ]]; then
              echo "Frontend 서비스 생성 최종 실패: $NEW_ARN"; exit 1
            fi
            echo "service-arn=$NEW_ARN" >> "$GITHUB_OUTPUT"
          fi

      - name: Wait for Frontend deployment
        run: |
          ARN="${{ steps.deploy.outputs.service-arn }}"
          for i in $(seq 1 30); do
            STATUS=$(aws apprunner describe-service \
              --service-arn "$ARN" --query 'Service.Status' --output text)
            echo "[$i/30] Frontend 상태: $STATUS"
            case "$STATUS" in
              RUNNING)   echo "Frontend 배포 성공!"; exit 0 ;;
              *_FAILED)  echo "Frontend 배포 실패: $STATUS"; exit 1 ;;
            esac
            sleep 30
          done
          echo "타임아웃"; exit 1

      - name: Get Frontend URL
        id: url
        run: |
          ARN="${{ steps.deploy.outputs.service-arn }}"
          URL=$(aws apprunner describe-service \
            --service-arn "$ARN" --query 'Service.ServiceUrl' --output text)
          echo "value=https://$URL" >> "$GITHUB_OUTPUT"
          echo "Frontend URL: https://$URL"

      - name: Summary
        run: |
          cat >> "$GITHUB_STEP_SUMMARY" <<EOF
          ## 전체 배포 완료 ✅
          | 항목 | 값 |
          |------|-----|
          | API | ${{ needs.deploy-api.outputs.api-url }} |
          | 프론트엔드 | ${{ steps.url.outputs.value }} |
          | 커밋 | \`${{ github.sha }}\` |
          EOF
